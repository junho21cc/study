Hash

// Hash란?
O(1)의 탐색 시간을 보장하는 자료구조 및 알고리즘
"모든 키의 레코드를 산술 연산에 의해 한 번에 바로 접근할 수 있는 기법"

해쉬의 구조
Key -> (Hash Function) -> Hash  index -> Record

// 해쉬 함수

1. 자릿수 선택(Digit Selection)
키의 값 중에서 일부 자릿수만 골라내서 인덱스를 생성하는 함수

2. 자릿수 접기(Digit Folding)
키의 각각의 자릿수를 더해서 인덱스를 생성하는 함수

3. 모듈로 연산(Modulo Function)
키를 해쉬 테이블의 크기로 나눈 나머지를 인덱스로 생성하는 함수

// 충돌(Collision)
서로다른 키를 가진 레코드가 해쉬함수에 의해서 동일한 인덱스로 대응되는 현상

// 충돌해소: 충돌이 발생한 레코드를 다른 주소에 저장하는 기법

1. 열린 어드레싱: 충돌발생 레코드를 다른 주소에 저장하는 방법
레코드의 주소 변경->열린 어드레싱
선형 탐사: index+a 에 저장한다. 끝까지 도달했으면 처음부터 다시한다.
	Tag사용: 다음원소를 가리키는 포인터
	클러스터링: 레코드가 분산되지 않고 군집되는 현상
제곱 탐사: index+a^a에 저장한다.
	2차 클러스터링 발생
이중 해시: 두개의 해쉬 함수 사용
	h1은 주어진 키로부터 인덱슬르 계산한느 해쉬 함수
	h2는 충돌 시 탐색할 인덱스의 간격을 의미


2. 닫힌 어드레싱: 충돌발생 레코드를 동일 주소에 저장하는 방법
레코드의 주소 미변경->닫힌 어드레싱
버켓: 해쉬 테이블의 각 원소들이 다시 여러 개의 원소를 이루어짐
       2차원 배열
       충돌되는 레코드를 하나의 인덱스에 둠
       사용되지 않는배열공간이 낭비됨
별도 체인: 해쉬 테이블의 각 원소들가 연결 리스트를 가리키는 헤드
	충돌이 일어날 때마다 해당 레코드를 연결 리스트의 첫 위치에 삽입
	동적 구조

